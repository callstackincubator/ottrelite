import CommonDirectiveDoc from './__common-directive.mdx';

## The autoinstrumentation directive

<CommonDirectiveDoc />

> [!NOTE]
> As seen in the examples below, the components are wrapped in `memo` to prevent unnecessary re-renders. This is a common practice in React to optimize performance, but it is not compulsory - the instrumentation would still work without it. However, in such case, it would be expected that most likely the instrumentation would produce many entries, for invocations of the component which didn't actually result in an update to the shadow tree.

```typescript
export const MyComponent = memo(function MyComponent(){
    "use trace";

    ...

    return ...;
});
```

Without memoization (be warned as per the notice above):

```typescript
export const MyComponent = function() {
    "use trace";

    ...

    return ...;
};
```

_Note: arrow function components are supported as well._

With an explicit Tracer name:

> [!NOTE]
> The name of the tracer is used to create a unique OTEL tracer, so make sure it is unique across your application.

```typescript
export const MyComponent = memo(function MyComponent(){
    "use trace dev TestLibMyComponent";

    ...

    return ...;
});
```

> [!WARNING]
> Please keep in mind that when using the `memo` helper (which is highly encouraged!), the name of the function will not be propagated from the assigned-to variable. For instance, the following code:
>
> ```typescript
> export const MyComponent = memo(function(){
>     "use trace";
>
>     ...
>
>     return ...;
> });
> ```
>
> Would result in an **error**, since the Babel plugin would not know the name of the component; for this reason, you need to either make the function a named function, or add an explicit name to the `"use trace API Name"` directive.

### What will be the name of the tracer?

The following is an in-order (by priority) list of how the name of the tracer is determined:

| Declaration style / context                         | Name                                     |
| --------------------------------------------------- | ---------------------------------------- |
| _Explicit name from the string after `"use trace"`_ | The passed string                        |
| component with `displayName` or `name`              | `displayName` or `name` property         |
| named function                                      | Name of the function                     |
| arrow function                                      | Name of the assignment target identifier |
| anonymous function                                  | Name of the assignment target identifier |

## `useComponentRenderTracing`

This hook traces a component's render lifecycle (i.e., any - first or subsequent - render), however in a different way than you might expect - please read the following explanation.

The start & end of the span (event) in the trace results is **not** the start & end time of JS render logic execution due to limitations coming from the concurrent root feature of React starting from v18 ([more about that here](https://legacy.reactjs.org/blog/2022/03/29/react-v18.html)). Concurrent rendering makes it possible for React to interrupt a render, effectively making this redundant. Since the Development API **must** maintain integrity within calls to begin/end event methods (e.g. orphaning a started event could cause all sorts of different problems, which could happen if the render was interrupted), it is not possible to simply synchronously start/end events within the render function.

Therefore, instead we capture the JS logic start and end times in a ref, trace the event from `useEffect` / `useLayoutEffect` hooks to produce a span that starts after its JS render logic finishes running, and ends after the component has been rendered to the tree. The measured JS logic render time is reported as an attribute named `jsLogicDuration` within that span.

Additional event arguments can be passed as the optional second argument to `useComponentRenderTracing`.

> [!WARNING]
> The hook **must** be called first in the component to mark the JS logic start time undelayed. Any components you render & return **must** first be stored in a variable, and returned **after** calling the hook's returned `markJSRenderEnd` function.

```typescript
function MyComponent() {
  const { markJSRenderEnd } = useComponentRenderTracing(heading, {
    attr1: "...",
    ...
  });

  // ...

  const contents = <View>{/* ... */}</View>;

  markJSRenderEnd();

  return contents;
}
```
