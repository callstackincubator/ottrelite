# Ottrelite interoperability package with OTEL

### OTEL interoperability

Ottrelite provides interoperability with OpenTelemetry (OTEL) through a set of adapter facilities.

#### Javascript

Firstly, Ottrelite provides its own `TracerProvider` ([`OttreliteTracerProvider.ts`](https://github.com/callstackincubator/ottrelite/blob/main/packages/interop-otel/src/otel/OttreliteTracerProvider.ts)) that provides adequate configuration for JS (configures the default resource to carry ottrelite's metadata, registers W3C & trace context baggage propagators, by default - `StackContextManager`). Invoking `register` on it, apart from the aforementioned, also calls invokes configuration of the global C++ API provider, described in the section below.

The analogous applies to [`OttreliteMeterProvider`](https://github.com/callstackincubator/ottrelite/blob/main/packages/interop-otel/src/otel/OttreliteMeterProvider.ts). An implementation detail difference is that the meter provider hooks into returned instrument creation methods & their return values dynamically by replacing properties on instances, to call its own logic before the original is executed.

The OTEL API is also hooked into by the [`DevSpanProcessorInterceptor.ts`](https://github.com/callstackincubator/ottrelite/blob/main/packages/interop-otel/src/otel/processor/DevSpanProcessorInterceptor.ts), which can be registered to propagate all OTEL spans live to the [Development API](https://callstackincubator.github.io/ottrelite/docs/core/quick-start.html#development-api-1).

#### C++

##### Usage

The global C++ Tracer and Meter Providers are registered - respectively - from `installGlobalOTELCPPTracerProvider` and `installGlobalOTELCPPMeterProvider` Nitro Module methods. Calling each of those makes sense **only once**. At the first call, the Ottrelite tracer/meter exporters that have been instantiated and registered in JavaScript so far, will also be registered in the C++ API. This is the single-implementation, single-configuration approach that Ottrelite follows: create & configure all tracer/meter exporters in JS, use them from JS, C++, Kotlin/Java & Swift code.

> [!WARNING]
> Invoking the aforementioned install methods more than once will discard all previously registered C++ tracer/meter exporters. It is important to first register all the tracer/meter exporters in JS, and then call the `register()` methods of `OttreliteTracerProvider` and `OttreliteMeterProvider` in JS.

##### Configuration

The `Ottrelite.install` method accepts 3 C++ OTEL SDK - specific configuration options:

1. `cppBatchLogRecordProcessorOptions` - options for the `opentelemetry::sdk::logs::BatchLogRecordProcessorFactory`
2. `cppMetricReaderOptions` - options for the `opentelemetry::sdk::metrics::PeriodicExportingMetricReaderFactory`
3. `cppTraceBatchSpanProcessorOptions` - options for the `opentelemetry::sdk::trace::opentelemetry::sdk::trace::BatchSpanProcessorFactory`

Those can only be passed once and will be used to configure the C++ OTEL SDK, which is the data sink for OTEL traces from all interoperability layers in all languages. However, those options will only affect the C++ data export - other languages will process, report & provide the spans according to their own setup.

##### Implementing a custom exporter

To implement a custom exporter, first create a C++ Nitro Module spec:

```typescript
// in MyOttreliteExporter.nitro.ts
import type { OttreliteExporter } from '@ottrelite/core';

export interface MyOttreliteExporter
  extends HybridObject<{ ios: 'c++'; android: 'c++' }>,
    OttreliteExporter {}
```

After codegen-ing the C++ glue code from this spec, implement the exporter in C++. The primary methods that are crucial for the implementation are:

- `void initExporter(const OTLPExporterConfig &config);`
- `void exportSpans(const std::vector<SerializedReadableSpan> &spans, const std::function<void(const ExportResult & /* result */)> &resultCallback);`
- `std::shared_ptr<Promise<void>> shutdown();`
- `std::shared_ptr<Promise<void>> forceFlush();`

Those methods are standard for OTEL exporters in according to its specification, yet the methods accept internal Ottrelite object types.

The `OTLPExporterConfig` is Nitro-codegened from [`OTLPExporterConfig.ts`](https://github.com/callstackincubator/ottrelite/blob/main/packages/interop-otel/src/types/OTLPExporterConfig.ts) and represents the most important JS configuration for exporters in general. If some more configuration levels are needed to be covered, please file a PR or issue.

The `ExportResult` is trivial and is a 1:1 CPP-JS mapping of the result type.

The `SerializedReadableSpan` is a representation of a span in JS. Due to some limitations of Nitro, the object currently is not possible to be passed to CPP 1:1, however the overhead of conversion is minimal: some properties are only cast as types, while some need to be remapped:

- due to Nitro codegen problems with recursive type references, some methods need to be masked & some types require aliases
- all `SpanContext` objects are serialized to a string using built-in JS OTEL functionality, which is then parsed on the C++ side using built-in C++ OTEL functionality

For conversion of `SerializedReadableSpan`s to C++ OTEL vector of `Recordable`s, the `::ottrelite::interop::otel::SpanConverter::convertSpans(spans, resourcesMemory)` from `SpanConverter.hpp` can be used:

```cpp
#include "SpanConverter.hpp"

// ...

// converted Resource-s must be kept in memory for the time of export
::ottrelite::interop::otel::ResourcesMemory resourcesMemory{};

auto recordables = ::ottrelite::interop::otel::SpanConverter::convertSpans(spans, resourcesMemory);

// create a span view for the exporter
opentelemetry::nostd::span<std::unique_ptr<opentelemetry::sdk::trace::Recordable>> spanView(
    recordables.data(), recordables.size());

// example: call the exporter's Export method
auto otelResult = otelExporterPtr->Export(spanView);
```

More hollistically, a vector of `SerializedReadableSpan` can be converted & exported on an exporter instance using

```cpp
#include "SpanConverter.hpp" // required for ResourcesMemory alias
#include "OTELExporterAdapterUtils.hpp"

// ...

// converted Resource-s must be kept in memory for the time of export
::ottrelite::interop::otel::ResourcesMemory resourcesMemory{};

resultCallback(::ottrelite::interop::otel::OTELExporterAdapterUtils::exportInternalSpansReprsViaOTEL(
    resourcesMemory, spans, otlpExporterPtr_));
```

#### Android

TODO: write this section

#### iOS

TODO: write this section

### Demo

The `examples/backend-jaeger` directory contains a Docker Compose file for running the Jaeger backend service. To run it, execute `docker compose up -d`, which will start the Jaeger backend with an OTLP collector, as well as serve Jaeger UI on `http://localhost:16686/` to collect OTEL data from the example app. Then, just run the app on the device you've run Jaeger on (otherwise, you will need to adjust endpoint path to match your server's address) and you should start seeing traces in the Jaeger UI.
